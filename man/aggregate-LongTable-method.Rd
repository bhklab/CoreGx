% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aggregate-methods.R
\name{aggregate,LongTable-method}
\alias{aggregate,LongTable-method}
\title{Functional API for aggregation over a \code{LongTable} or inheriting class}
\usage{
\S4method{aggregate}{LongTable}(x, assay, by, ..., nthread = 1, BPPARAM = NULL)
}
\arguments{
\item{x}{\code{LongTable} or inheriting class to compute aggregation on.}

\item{assay}{\code{character(1)} The assay to aggregate over.}

\item{by}{\code{character} One or more valid column names in \code{x} to compute
groups using.}

\item{...}{\code{call} One or more aggregations to compute for each group by in x.
If you name aggregation calls, that will be the column name of the value
in the resulting \code{data.table} otherwise a default name will be parsed from
the function name and its first arugment, which is assumed to be the name
of the column being aggregated over.}

\item{nthread}{\code{numeric(1)} Number of threads to use for split-apply-combine
parallelization. Uses \code{BiocParllel::bplapply} if nthread > 1. Does not
modify data.table threads, so be sure to use setDTthreads for reasonable
nested parallelism.}

\item{BPPARAM}{\code{BiocParallelParam} object. Use to customized the
the parallization back-end of bplapply. Note, nthread over-rides any
settings from BPPARAM. For now, a progress bar is always used.}
}
\value{
\code{data.table} of aggregation results.
}
\description{
Compute a group-by operation over a \code{LongTable} object or it's inhering
classes.
}
\details{
\subsection{Use of Non-Standard Evaluation}{

Arguments in \code{...} are substituted and wrapped in a list, which is passed
through to the j argument of \verb{[.data.table} internally. The functin currently
tries to build informative column names for unnamed arguments in \code{...} by
appending the name of each function call with the name of its first argument,
which is assumed to be the column name being aggregated over. If an argument
to \code{...} is named, that will be the column name of its value in the resulting
\code{data.table}.
}

\subsection{Parallelization Strategies}{

While your first instinct may be to make use of all available cores, because
this method uses \code{data.table} internally for aggregation the optimal way
to compute a set of aggregate functions is dependent on the functions being
called. For functions which \code{data.table} optimizes intenally, such as \code{mean},
\code{sd} and other (see \code{?gforce} for full list of optimized functons)
}
}
\seealso{
\verb{data.table::[.data.table}, \code{BiocParallel::bplapply}
}
