% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aggregate-methods.R
\name{aggregate,data.table-method}
\alias{aggregate,data.table-method}
\title{Functional S4 API for aggregation over a \code{data.table} object.}
\usage{
\S4method{aggregate}{data.table}(
  x,
  by,
  ...,
  subset = TRUE,
  nthread = 1,
  progress = TRUE,
  BPPARAM = NULL,
  enlist = TRUE,
  moreArgs = list()
)
}
\arguments{
\item{x}{\code{data.table} to compute aggregation over.}

\item{by}{\code{character} One or more valid column names in \code{x} to compute
groups using.}

\item{...}{\code{call} One or more aggregations to compute for each group by in x.
If you name aggregation calls, that will be the column name of the value
in the resulting \code{data.table} otherwise a default name will be parsed from
the function name and its first argument, which is assumed to be the name
of the column being aggregated over.}

\item{subset}{\code{call} An R call to evaluate before perfoming an aggregate.
This allows you to aggregate over a subset of columns in an assay but have
it be assigned to the parent object. Default is TRUE, which includes all
rows. Passed through as the \code{i} argument in \verb{[.data.table}.}

\item{nthread}{\code{numeric(1)} Number of threads to use for split-apply-combine
parallelization. Uses \code{BiocParllel::bplapply} if nthread > 1 or you pass in
\code{BPPARAM}. Does not modify data.table threads, so be sure to use
setDTthreads for reasonable nested parallelism. See details for performance
considerations.}

\item{progress}{\code{logical(1)} Display a progress bar for parallelized
computations? Only works if \verb{bpprogressbar<-} is defined for the current
BiocParallel back-end.}

\item{BPPARAM}{\code{BiocParallelParam} object. Use to customized the
the parallization back-end of bplapply. Note, nthread over-rides any
settings from BPPARAM as long as \verb{bpworkers<-} is defined for that class.}

\item{enlist}{\code{logical(1)} Default is \code{TRUE}. Set to \code{FALSE} to evaluate
the first call in \code{...} within \code{data.table} groups. See details for more
information.}

\item{moreArgs}{\code{list()} A named list where each item is an argument one of
the calls in \code{...} which is not a column in the table being aggregated. Use
to further parameterize you calls.}
}
\value{
\code{data.table} of aggregated results with an \code{aggregations} attribute
capturing metadata about the last aggregation performed on the table.
}
\description{
Compute a group-by operation over a \code{data.table} in a functional, pipe
compatible format.
}
\details{
This S4 method override the default \code{aggregate} method for a \code{data.frame}
and as such you need to call \code{aggregate.data.frame} directly to get the
original S3 method for a \code{data.table}.

\subsection{Use of Non-Standard Evaluation}{

Arguments in \code{...} are substituted and wrapped in a list, which is passed
through to the j argument of \verb{[.data.table} internally. The function currently
tries to build informative column names for unnamed arguments in \code{...} by
appending the name of each function call with the name of its first argument,
which is assumed to be the column name being aggregated over. If an argument
to \code{...} is named, that will be the column name of its value in the resulting
\code{data.table}.
}

\subsection{Parallelization Strategies}{

While your first instinct may be to make use of all available cores, because
this method uses \code{data.table} internally for aggregation the optimal way
to compute a set of aggregate functions is dependent on the functions being
called. For functions which \code{data.table} optimizes intenally, such as \code{mean},
\code{sd} and others (see \code{?gforce} for full list of optimized functons) it is
almost always better to run this function with \code{nthread=1} and let
\code{data.table} handle parallelization.
However, for functions not internally optimized by \code{data.table}, such as
fitting statistical models, compute time can be reduced by adding
more cores at the cost of additional memory usage.
}

\subsection{Enlisting}{

The primary use case for \code{enlist=FALSE} is to allow computation of dependent
aggregations, where the output from a previous aggregation is required in a
subsequent one. For this case, wrap your call in \verb{\{} and assign intermediate
results to variables, returning the final results as a list where each list
item will become a column in the final table with the corresponding name.
Name inference is disabled for this case, since it is assumed you will name
the returned list items appropriately.
A major advantage over multiple calls to \code{aggregate} is that
the overhead of parallelization is paid only once even for complex multi-step
computations like fitting a model, capturing its paramters, and making
predictions using it. It also allows capturing arbitrarily complex calls
which can be recomputed later using the
\verb{update,TreatmentResponseExperiment-method}
A potential disadvantage is increased RAM usage per
thread due to storing intermediate values in variables, as well as any
memory allocation overhead associate therewith.
}
}
