% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/LongTable-class.R, R/methods-[[.R,
%   R/methods-assay.R, R/methods-assayNames.R, R/methods-assays.R,
%   R/methods-buildLongTable.R, R/methods-colData.R, R/methods-dim.R,
%   R/methods-dimnames.R, R/methods-getIntern.R, R/methods-rowData.R
\docType{class}
\name{LongTable-class}
\alias{LongTable-class}
\alias{.LongTable}
\alias{rowIDs,LongTable-method}
\alias{rowMeta,LongTable-method}
\alias{colIDs,LongTable-method}
\alias{colMeta,LongTable-method}
\alias{assayCols,LongTable-method}
\alias{[[,LongTable,ANY,ANY-method}
\alias{assay,LongTable,ANY-method}
\alias{assay<-,LongTable,character-method}
\alias{assayNames,LongTable-method}
\alias{assays,LongTable-method}
\alias{assays<-,LongTable,list-method}
\alias{buildLongTable,data.frame-method}
\alias{buildLongTable,character-method}
\alias{colData,LongTable-method}
\alias{colData<-,LongTable,ANY-method}
\alias{dim,LongTable-method}
\alias{colnames,LongTable-method}
\alias{rownames,LongTable-method}
\alias{dimnames,LongTable-method}
\alias{getIntern,LongTable,character-method}
\alias{rowData,LongTable-method}
\alias{rowData<-,LongTable-method}
\title{LongTable class definition}
\usage{
\S4method{rowIDs}{LongTable}(object, data = FALSE, key = FALSE)

\S4method{rowMeta}{LongTable}(object, data = FALSE, key = FALSE)

\S4method{colIDs}{LongTable}(object, data = FALSE, key = FALSE)

\S4method{colMeta}{LongTable}(object, data = FALSE, key = FALSE)

\S4method{assayCols}{LongTable}(object, i)

\S4method{[[}{LongTable,ANY,ANY}(x, i, withDimnames = TRUE, metadata = withDimnames, keys = !withDimnames)

\S4method{assay}{LongTable,ANY}(x, i, withDimnames = FALSE, metadata = withDimnames, key = !withDimnames)

\S4method{assay}{LongTable,character}(x, i) <- value

\S4method{assayNames}{LongTable}(x)

\S4method{assays}{LongTable}(x, withDimnames = FALSE, metadata = withDimnames, key = !withDimnames)

\S4method{assays}{LongTable,list}(x) <- value

\S4method{buildLongTable}{data.frame}(from, rowDataCols, colDataCols, assayCols)

\S4method{buildLongTable}{character}(from, rowDataCols, colDataCols, assayCols)

\S4method{colData}{LongTable}(x, key = FALSE)

\S4method{colData}{LongTable,ANY}(x) <- value

\S4method{dim}{LongTable}(x)

\S4method{colnames}{LongTable}(x)

\S4method{rownames}{LongTable}(x)

\S4method{dimnames}{LongTable}(x)

\S4method{getIntern}{LongTable,character}(object, x, ...)

\S4method{rowData}{LongTable}(x, key = FALSE, use.names = FALSE)

\S4method{rowData}{LongTable}(x) <- value
}
\arguments{
\item{object}{\code{LongTable}}

\item{data}{\code{logical} Should the colData for the metadata columns be returned
instead of the column names? Default is FALSE.}

\item{key}{\code{logical} Should the rowKey column also be returned? Defaults
to FALSE.}

\item{i}{\code{integer} or \code{character} vector containing the index or name
of the assay to update.}

\item{x}{A \code{LongTable} object to modify.}

\item{withDimnames}{\code{logical} Should the returned assays be joined to
the row and column identifiers (i.e., the pseudo dimnames of the object).}

\item{metadata}{\code{logical} Should row and column metadata also be joined
to the returned assays. This is useful for modifying assays before
reconstructing a new LongTable.}

\item{keys}{\code{logical} Should the row and column keys also be returned?
Defaults to !withDimnames.}

\item{value}{A \code{data.table} or \code{data.frame} to update the \code{rowData} of
\code{x} with.}

\item{from}{\code{character} Path to the .csv file containing the data and
metadata from which to build the \code{LongTable}.}

\item{rowDataCols}{\code{list} List with two \code{character} vectors, the first
specifying one or more columns to be used as cell identifiers (e.g.,
cell-line name columns) and the second containing any additional metadata
columns related to the cell identifiers.}

\item{colDataCols}{\code{list} List with two \code{character} vectors, the first
specifying one or more columns to be used as column identifiers (e.g.,
drug name columns) and the second containing any additional metadata
columns related to the column identifiers.}

\item{assayCols}{\code{list} A named list of character vectors specifying how to
parse assay columns into a list of \code{data.table}s. Each list data.table
will be named for the name of corresponding list item and contain the columns
specified in the character vector of column names in each list item.}

\item{...}{\code{pairlist} Addtional arguments to get or mget inside of the
function.}

\item{use.names}{\code{logical} This parameter is just here to stop matching
the key argument to use.names from the rowData generic. It doesn't do
anything at this time and can be ignored.}
}
\value{
\code{LongTable} object containing the assay data from a treatment
response experiment

A \code{character} vector of rowData column names if data is FALSE,
otherwise a \code{data.table} with the data from the rowData id columns.

A \code{character} vector of rowData column names if data is FALSE,
otherwise a \code{data.table} with the data from the rowData metadta columns.

A \code{character} vector of colData column names if data is FALSE,
otherwise a \code{data.table} with the data from the colData id columns.

A \code{character} vector of colData column names if data is FALSE,
otherwise a \code{data.table} with the data from the colData metadta columns.

A \code{list} of \code{character} vectors containing the value column names for
each assay if i is missing, otherwise a \code{character} vector of value column
names for the selected assay.

\code{LongTable} With updated assays slot.

\code{character} Names of the assays contained in the \code{LongTable}.

A \code{list} of \code{data.table} objects, one per assay in the object.

A copy of the \code{LongTable} with the assays modified.

A \code{LongTable} object containing one or more assays, indexed by
rowID and colID.

A \code{LongTable} object containing one or more assays, indexed by
rowID and colID.

A \code{data.table} containing row identifiers and metadata.

A copy of the \code{LongTable} object with the \code{colData}
slot updated.

\code{numeric} Vector of object dimensions.

\code{character} Vector of column names.

\code{character} Vector of row names.

\code{list} List with two character vectors, one for row and one for
column names.

value of x if length(x) == 1 else named list of values for all
symbols in x

A \code{data.table} containing rowID, row identifiers, and row metadata.

A copy of the \code{LongTable} object with the \code{rowData}
slot updated.
}
\description{
Define a private constructor method to be used to build a
\code{LongTable} object.

Select an assay from within a LongTable object.

Add or replace an assay in a LongTable by name. Currently
this function only works when the assay has all columns in row and column
data tables (i.e., when assays is retured withDimnames=TRUE). This will
be fixed in future updates.

This is used as an alternative to R attributes for storing structural
metadata of S4 objects.
}
\section{Methods (by generic)}{
\itemize{
\item \code{rowMeta}: Get the names of the non-id columns from rowData.

\item \code{colIDs}: Get the names of the columns in colData required to
uniquely identify each row.

\item \code{colMeta}: Get the names of the non-id columns in the colData
\code{data.table}.

\item \code{assayCols}: Get a list of column names for each assay in a
\code{LongTable}.

\item \code{[[}: Get an assay from a LongTable object. This method
returns the row and column annotations by default to make assignment
and aggregate operations easiers.

\item \code{assay}: Retrieve an assay \code{data.table} object from the
\code{assays} slot of a \code{LongTable} object.

\item \code{assay<-}: 

\item \code{assayNames}: Return the names of the assays contained in a
\code{LongTable}

\item \code{assays}: Get a list containing all the assays in a \code{LongTable}.

\item \code{assays<-}: Update the assays in a LongTable object. The rowIDs
and colIDs must be present in all assays to allow successfully remapping
the keys. We recommend modifying the list returned by
assays(longTable, withDimnames=TRUE) and the reassigning to the \code{LongTable}.

\item \code{buildLongTable}: Create a LongTable object from a single data.table or
data.frame object.

\item \code{buildLongTable}: Create a LongTable object from a single .csv file

\item \code{colData}: Get the column level annotations for a LongTable
object.

\item \code{colData<-}: Upadte the colData of a LongTable object. Currently
requires that all of the colIDs(longTable) be in the value object.

\item \code{dim}: Get the number of row annotations by the number of
column annotations from a LongTable object. Please note that row x columns
does not necessarily equal the number of rows in an assay, since it is
not required for each assay to have every row or column present.

\item \code{colnames}: Retrieve the pseudo-colnames of a LongTable object,
these are constructed by pasting together the colIDs(longTable) and
can be used in the subset method for regex based queries.

\item \code{rownames}: Retrieve the pseudo-rownames of a LongTable object,
these are constructed by pasting together the rowIDs(longTable) and
can be used in the subset method for regex based queries.

\item \code{dimnames}: Get the pseudo-dimnames for a LongTable object. See
colnames and rownames for more information.

\item \code{getIntern}: Access structural metadata present within a
LongTable object. This is mostly for developmer use.

\item \code{rowData}: Get the row level annotations for a \code{LongTable} object.

\item \code{rowData<-}: Update the row annotations for a \code{LongTable} object.
Currently requires that all columns in rowIDs(longTable) be present in
value.
}}

\section{Slots}{

\itemize{
\item \emph{rowData}: A \code{data.table} containing the metadata associated with the
row dimension of a \code{LongTable}.
\item \emph{colData}: A \code{data.table} containing the metadata associated with the
column dimension of a \code{LongTable}.
\item \emph{assays}: A \code{list} of \code{data.table}s, one for each assay in a
\code{LongTable}.
\item \emph{metadata}: An optional \code{list} of additional metadata for a \code{LongTable}
which doesn't map to one of the dimensions.
\item \emph{.intern}: An \code{environment} that holds internal structural metadata
about a LongTable object, such as which columns are required to key
the object. An environment has been used to allow locking items, which
can prevent accidental modification of a property required for the class
to work.
}
}

\examples{
rowIDs(merckLongTable)

rowMeta(merckLongTable)

colIDs(merckLongTable)

colMeta(merckLongTable)

assayCols(merckLongTable)

merckLongTable[['viability']]

# Default annotations, just the key columns
assay(merckLongTable, 'viability')
assay(merckLongTable, 1)

# With identifiers joined
assay(merckLongTable, 'viability', withDimnames=TRUE)

# With identifiers and metadata
assay(merckLongTable, 'viability_summary', withDimnames=TRUE, metadata=TRUE)

assay(merckLongTable, 'viability') <- assay(merckLongTable, 'viability', withDimnames=TRUE)
assay(merckLongTable, 'viability') <- merckLongTable$viability

assayNames(merckLongTable)

assays(merckLongTable)

assays(merckLongTable) <- assays(merckLongTable, withDimnames=TRUE)

colData(merckLongTable)

# Get the keys as well, mostly for internal use
colData(merckLongTable, key=TRUE)

colData(merckLongTable) <- colData(merckLongTable)

dim(merckLongTable)

dim(merckLongTable)

head(colnames(merckLongTable))

head(rownames(merckLongTable))

lapply(dimnames(merckLongTable), head)

getIntern(merckLongTable, 'rowIDs')
getIntern(merckLongTable, c('colIDs', 'colMeta'))

rowData(merckLongTable)

rowData(merckLongTable) <- rowData(merckLongTable)

}
\concept{LongTable-accessors}
\concept{LongTable-class}
\keyword{internal}
