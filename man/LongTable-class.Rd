% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/class-LongTable.R, R/methods-[[.R,
%   R/methods-assay.R, R/methods-assayNames.R, R/methods-assays.R
\docType{class}
\name{LongTable-class}
\alias{LongTable-class}
\alias{.LongTable}
\alias{[[,LongTable,ANY,ANY-method}
\alias{assay,LongTable,ANY-method}
\alias{assay<-,LongTable,character-method}
\alias{assayNames,LongTable-method}
\alias{assays<-,LongTable,list-method}
\title{LongTable class definition}
\usage{
\S4method{[[}{LongTable,ANY,ANY}(x, i, keys = FALSE, withDimnames = TRUE, metadata = FALSE)

\S4method{assay}{LongTable,ANY}(x, i, withDimnames = FALSE, metadata = FALSE, key = !withDimnames)

\S4method{assay}{LongTable,character}(x, i) <- value

\S4method{assayNames}{LongTable}(x)

\S4method{assays}{LongTable,list}(x) <- value
}
\arguments{
\item{x}{A [`LongTable`] to modify the assays in.}

\item{i}{[`integer`] or [`character`] vector containing the index or name
of the assay to update.}

\item{keys}{[`logical`] Should the row and column keys also be returned?
Defaults to FALSE to make applying aggregate functions more convenient.}

\item{withDimnames}{[`logical`] Should the dimension names be returned
joined to the assay. This retrieves both the row and column identifiers
and returns them attached to the}

\item{metadata}{[`logical`] Should all of the metadata also be joined to
the assay. This is useful when modifying assays as the resulting list
has all the information needed to recreated the LongTable object.}

\item{key}{[`logical`] Should the key columns also be returned? Defaults to
!withDimnames.}

\item{value}{A [`list`] of `data.frame` or `data.table` objects, all of which
contain the row and column identifiers and metadata.}
}
\value{
[`LongTable`] object containing the assay data from a treatment
  response experiment

[`LongTable`] With updated assays slot.

[`character`] Names of the assays contained in the `LongTable`.

A copy of the [`LongTable`] with the assays modified.
}
\description{
Define a private constructor method to be used to build a
  `LongTable` object.

Select an assay from within a LongTable object.
}
\section{Methods (by generic)}{
\itemize{
\item \code{[[}: 

\item \code{assay}: Retrieve an assay `data.table` object from the
`assays` slot of a `LongTable` object.

\item \code{assay<-}: Add or replace an assay in a LongTable by name.

\item \code{assayNames}: Return the names of the assays contained in a
`LongTable`

\item \code{assays<-}: Update the assays in a LongTable object. The rowIDs
and colIDs must be present in all assays to allow successfully remapping
the keys. We recommend modifying the list returned by
assays(longTable, withDimnames=TRUE) and the reassigning to the `LongTable`.
}}

\section{Slots}{

\describe{
\item{\code{rowData}}{A [`data.table`] containing the metadata associated with the
row dimension of a `LongTable`.}

\item{\code{colData}}{A [`data.table`] containing the metadata associated with the
column dimension of a `LongTable`.}

\item{\code{assays}}{A [`list`] of [`data.table`s], one for each assay in a
`LongTable`.}

\item{\code{metadata}}{An optional [`list`] of additional metadata for a `LongTable`
which doesn't map to one of the dimensions.}

\item{\code{.intern}}{An [`enivornment`] that holds internal structural metadata
about a LongTable object, such as which columns are required to key
the object. An environment has been used to allow locking items, which
can prevent accidental modification of a property required for the class
to work.}
}}

\examples{
data(merckLongTable)

# Default annotations, just the key columns
assay(merckLongTable, 'viability')
assay(merckLongTable, 1)

# With identifiers joined
assay(merckLongTable, 'viability', withDimnames=TRUE)

# With identifiers and metadata
assay(merckLongTable, 'viability_summary', withDimnames=TRUE, metadata=TRUE)

data(merckLongTable)
assay(merckLongTable, 'viability') <- assay(merckLongTable, 'viability', withDimnames=TRUE)
assay(merckLongTable, 'viability') <- merckLongTable$viability

data(merckLongTable)
assayNames(merckLongTable)

data(merckLongTable)
assays(merckLongTable) <- assays(merckLongTable, withDimnames=TRUE)

}
\keyword{internal}
