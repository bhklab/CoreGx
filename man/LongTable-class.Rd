% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/class-LongTable.R, R/methods-[[.R,
%   R/methods-assay.R, R/methods-assayNames.R, R/methods-assays.R,
%   R/methods-buildLongTable.R, R/methods-colData.R, R/methods-dim.R,
%   R/methods-dimnames.R, R/methods-getIntern.R, R/methods-rowData.R
\docType{class}
\name{LongTable-class}
\alias{LongTable-class}
\alias{.LongTable}
\alias{rowIDs,LongTable-method}
\alias{rowMeta,LongTable-method}
\alias{colIDs,LongTable-method}
\alias{colMeta,LongTable-method}
\alias{assayCols,LongTable-method}
\alias{[[,LongTable,ANY,ANY-method}
\alias{assay,LongTable,ANY-method}
\alias{assay<-,LongTable,character-method}
\alias{assayNames,LongTable-method}
\alias{assays,LongTable-method}
\alias{assays<-,LongTable,list-method}
\alias{buildLongTable,data.frame-method}
\alias{buildLongTable,character-method}
\alias{colData,LongTable-method}
\alias{colData<-,LongTable,ANY-method}
\alias{dim,LongTable-method}
\alias{colnames,LongTable-method}
\alias{rownames,LongTable-method}
\alias{dimnames,LongTable-method}
\alias{getIntern,LongTable,character-method}
\alias{rowData,LongTable-method}
\alias{rowData<-,LongTable-method}
\title{LongTable class definition}
\usage{
\S4method{rowIDs}{LongTable}(object, data = FALSE, key = FALSE)

\S4method{rowMeta}{LongTable}(object, data = FALSE, key = FALSE)

\S4method{colIDs}{LongTable}(object, data = FALSE, key = FALSE)

\S4method{colMeta}{LongTable}(object, data = FALSE, key = FALSE)

\S4method{assayCols}{LongTable}(object, i)

\S4method{[[}{LongTable,ANY,ANY}(x, i, withDimnames = TRUE, metadata = withDimnames, keys = !withDimnames)

\S4method{assay}{LongTable,ANY}(x, i, withDimnames = FALSE, metadata = withDimnames, key = !withDimnames)

\S4method{assay}{LongTable,character}(x, i) <- value

\S4method{assayNames}{LongTable}(x)

\S4method{assays}{LongTable}(x, withDimnames = FALSE, metadata = withDimnames, key = !withDimnames)

\S4method{assays}{LongTable,list}(x) <- value

\S4method{buildLongTable}{data.frame}(from, rowDataCols, colDataCols, assayCols)

\S4method{buildLongTable}{character}(from, rowDataCols, colDataCols, assayCols)

\S4method{colData}{LongTable}(x, key = FALSE)

\S4method{colData}{LongTable,ANY}(x) <- value

\S4method{dim}{LongTable}(x)

\S4method{colnames}{LongTable}(x)

\S4method{rownames}{LongTable}(x)

\S4method{dimnames}{LongTable}(x)

\S4method{getIntern}{LongTable,character}(object, x, ...)

\S4method{rowData}{LongTable}(x, key = FALSE, use.names = FALSE)

\S4method{rowData}{LongTable}(x) <- value
}
\arguments{
\item{object}{[`LongTable`]}

\item{data}{[`logical`] Should the colData for the metadata columns be returned
instead of the column names? Default is FALSE.}

\item{key}{[`logical`] Should the rowKey column also be returned? Defaults
to FALSE.}

\item{i}{[`integer`] or [`character`] vector containing the index or name
of the assay to update.}

\item{x}{A [`LongTable`] object to modify.}

\item{withDimnames}{[`logical`] Should the returned assays be joined to
the row and column identifiers (i.e., the pseudo dimnames of the object).}

\item{metadata}{[`logical`] Should row and column metadata also be joined
to the returned assays. This is useful for modifying assays before
reconstructing a new LongTable.}

\item{keys}{[`logical`] Should the row and column keys also be returned?
Defaults to !withDimnames.}

\item{value}{A [`data.table`] or [`data.frame`] to update}

\item{from}{[`character`] Path to the .csv file containing the data and
metadata from which to build the `LongTable`.}

\item{rowDataCols}{[`list`] List with two `character` vectors, the first
specifying one or more columns to be used as cell identifiers (e.g.,
cell-line name columns) and the second containing any additional metadata
columns related to the cell identifiers.}

\item{colDataCols}{[`list`] List with two `character` vectors, the first
specifying one or more columns to be used as column identifiers (e.g.,
drug name columns) and the second containing any additional metadata
columns related to the column identifiers.}

\item{assayCols}{[`list`] A named list of character vectors specifying how to
parse assay columns into a list of `data.table`s. Each list data.table
will be named for the name of corresponding list item and contain the columns
specified in the character vector of column names in each list item.}

\item{...}{[`pairlist`] Addtional arguments to get or mget inside of the
function.}

\item{use.names}{[`logical`] This parameter is just here to stop matching
the key argument to use.names from the rowData generic. It doesn't do
anything at this time and can be ignored.}
}
\value{
[`LongTable`] object containing the assay data from a treatment
  response experiment

A [`character`] vector of rowData column names if data is FALSE,
otherwise a [`data.table`] with the data from the rowData id columns.

A [`character`] vector of rowData column names if data is FALSE,
otherwise a [`data.table`] with the data from the rowData metadta columns.

A [`character`] vector of colData column names if data is FALSE,
otherwise a [`data.table`] with the data from the colData id columns.

A [`character`] vector of colData column names if data is FALSE,
  otherwise a [`data.table`] with the data from the colData metadta columns.

A [`list`] of `character` vectors containing the value column names for
each assay if i is missing, otherwise a `character` vector of value column
names for the selected assay.

[`LongTable`] With updated assays slot.

[`character`] Names of the assays contained in the `LongTable`.

A [`list`] of `data.table` objects, one per assay in the object.

A copy of the [`LongTable`] with the assays modified.

A [`LongTable`] object containing one or more assays, indexed by
  rowID and colID.

A [`LongTable`] object containing one or more assays, indexed by
  rowID and colID.

A [`data.table`] containing row identifiers and metadata.

A copy of the [`LongTable`] object with the `colData`
  slot updated.

[`numeric`] Vector of object dimensions.

[`character`] Vector of column names.

[`character`] Vector of row names.

[`list`] List with two character vectors, one for row and one for
    column names.

value of x if length(x) == 1 else named list of values for all
    symbols in x

A [`data.table`] containing rowID, row identifiers, and row metadata.

A copy of the [`LongTable`] object with the `rowData`
  slot updated.
}
\description{
Define a private constructor method to be used to build a
  `LongTable` object.

Select an assay from within a LongTable object.

This is used as an alternative to R attributes for storing structural
metadata of S4 objects.
}
\section{Methods (by generic)}{
\itemize{
\item \code{rowIDs}: Get the names of the rowData columns required to
uniquely identify each row.

\item \code{rowMeta}: Get the names of the non-id columns from rowData.

\item \code{colIDs}: Get the names of the columns in colData required to
uniquely identify each row.

\item \code{colMeta}: Get the names of the non-id columns in the colData
`data.table`.

\item \code{assayCols}: Get a list of column names for each assay in a
`LongTable`.

\item \code{[[}: Get an assay from a LongTable object. This method
returns the row and column annotations by default to make assignment
and aggregate operations easiers.

\item \code{assay}: Retrieve an assay `data.table` object from the
`assays` slot of a `LongTable` object.

\item \code{assay<-}: Add or replace an assay in a LongTable by name. Currently
this function only works when the assay has all columns in row and column
data tables (i.e., when assays is retured withDimnames=TRUE). This will
be fixed in future updates.

\item \code{assayNames}: Return the names of the assays contained in a
`LongTable`

\item \code{assays}: Get a list containing all the assays in a `LongTable`.

\item \code{assays<-}: Update the assays in a LongTable object. The rowIDs
and colIDs must be present in all assays to allow successfully remapping
the keys. We recommend modifying the list returned by
assays(longTable, withDimnames=TRUE) and the reassigning to the `LongTable`.

\item \code{buildLongTable}: Create a LongTable object from a single data.table or
data.frame object.

\item \code{buildLongTable}: Create a LongTable object from a single .csv file

\item \code{colData}: Get the column level annotations for a LongTable
object.

\item \code{colData<-}: Upadte the colData of a LongTable object. Currently
requires that all of the colIDs(longTable) be in the value object.

\item \code{dim}: Get the number of row annotations by the number of
column annotations from a LongTable object. Please note that row x columns
does not necessarily equal the number of rows in an assay, since it is
not required for each assay to have every row or column present.

\item \code{colnames}: Retrieve the pseudo-colnames of a LongTable object,
these are constructed by pasting together the colIDs(longTable) and
can be used in the subset method for regex based queries.

\item \code{rownames}: Retrieve the pseudo-rownames of a LongTable object,
these are constructed by pasting together the rowIDs(longTable) and
can be used in the subset method for regex based queries.

\item \code{dimnames}: Get the pseudo-dimnames for a LongTable object. See
colnames and rownames for more information.

\item \code{getIntern}: Access structural metadata present within a
LongTable object. This is mostly for developmer use.

\item \code{rowData}: Get the row level annotations for a `LongTable` object.

\item \code{rowData<-}: Update the row annotations for a `LongTable` object.
Currently requires that all columns in rowIDs(longTable) be present in
value.
}}

\section{Slots}{

\describe{
\item{\code{rowData}}{A [`data.table`] containing the metadata associated with the
row dimension of a `LongTable`.}

\item{\code{colData}}{A [`data.table`] containing the metadata associated with the
column dimension of a `LongTable`.}

\item{\code{assays}}{A [`list`] of [`data.table`s], one for each assay in a
`LongTable`.}

\item{\code{metadata}}{An optional [`list`] of additional metadata for a `LongTable`
which doesn't map to one of the dimensions.}

\item{\code{.intern}}{An [`enivornment`] that holds internal structural metadata
about a LongTable object, such as which columns are required to key
the object. An environment has been used to allow locking items, which
can prevent accidental modification of a property required for the class
to work.}
}}

\examples{
rowIDs(merckLongTable)

rowMeta(merckLongTable)

colIDs(merckLongTable)

colMeta(merckLongTable)

assayCols(merckLongTable)

merckLongTable[['viability']]

# Default annotations, just the key columns
assay(merckLongTable, 'viability')
assay(merckLongTable, 1)

# With identifiers joined
assay(merckLongTable, 'viability', withDimnames=TRUE)

# With identifiers and metadata
assay(merckLongTable, 'viability_summary', withDimnames=TRUE, metadata=TRUE)

assay(merckLongTable, 'viability') <- assay(merckLongTable, 'viability', withDimnames=TRUE)
assay(merckLongTable, 'viability') <- merckLongTable$viability

assayNames(merckLongTable)

assays(merckLongTable)

assays(merckLongTable) <- assays(merckLongTable, withDimnames=TRUE)

colData(merckLongTable)

# Get the keys as well, mostly for internal use
colData(merckLongTable, key=TRUE)

colData(merckLongTable) <- colData(merckLongTable)

dim(merckLongTable)

dim(merckLongTable)

head(colnames(merckLongTable))

head(rownames(merckLongTable))

lapply(dimnames(merckLongTable), head)

getIntern(merckLongTable, 'rowIDs')
getIntern(merckLongTable, c('colIDs', 'colMeta'))

rowData(merckLongTable)

rowData(merckLongTable) <- rowData(merckLongTable)

}
\keyword{internal}
