% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aggregate-methods.R
\name{aggregate2}
\alias{aggregate2}
\title{Functional API for data.table aggregation which allows capture of associated
aggregate calls so they can be recomputed later.}
\usage{
aggregate2(x, by, ..., nthread = 1, BPPARAM = NULL)
}
\arguments{
\item{x}{\code{data.table}}

\item{by}{\code{character} One or more valid column names in \code{x} to compute
groups using.}

\item{...}{\code{call} One or more aggregations to compute for each group by in x.
If you name aggregation calls, that will be the column name of the value
in the resulting \code{data.table} otherwise a default name will be parsed from
the function name and its first arugment, which is assumed to be the name
of the column being aggregated over.}

\item{nthread}{\code{numeric(1)} Number of threads to use for split-apply-combine
parallelization. Uses \code{BiocParllel::bplapply} if nthread > 1. Does not
modify data.table threads, so be sure to use setDTthreads for reasonable
nested parallelism.}

\item{BPPARAM}{\code{BiocParallelParam} object. Use to customized the
the parallization back-end of bplapply. Note, nthread over-rides any
settings from BPPARAM. For now, a progress bar is always used.}
}
\value{
\code{data.table} of aggregation results.
}
\description{
Functional API for data.table aggregation which allows capture of associated
aggregate calls so they can be recomputed later.
}
\details{
\subsection{Use of Non-Standard Evaluation}{

Arguments in \code{...} are substituted and wrapped in a list, which is passed
through to the j argument of \verb{[.data.table} internally. The functin currently
tries to build informative column names for unnamed arguments in \code{...} by
appending the name of each function call with the name of its first argument,
which is assumed to be the column name being aggregated over. If an argument
to \code{...} is named, that will be the column name of its value in the resulting
\code{data.table}.
}

\subsection{Parallelization Strategies}{

While your first instinct may be to make use of all available cores, because
this method uses \code{data.table} internally for aggregation the optimal way
to compute a set of aggregate functions is dependent on the functions being
called. For functions which \code{data.table} optimizes intenally, such as \code{mean},
\code{sd} and others (see \code{?gforce} for full list of optimized functons) it is
almost always better to run this function with \code{nthread=1} and let
\code{data.table} handle paralellization.

However, for functions not internally optimized by \code{data.table}, such as
different statistical modelling method, compute time can be reduced by adding
more cores at the cost of additional memory usage.
}
}
\seealso{
\verb{data.table::[.data.table}, \code{BiocParallel::bplapply}
}
